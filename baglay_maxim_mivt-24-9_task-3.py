# Задача 3. Кэширование для ускорения вычислений
# Контекст
# Вы разрабатываете программу для оптимизации вычислений чисел Фибоначчи. Числа Фибоначчи вычисляются рекурсивной функцией, каждое число равно сумме двух предыдущих чисел. Однако вы заметили, что при больших значениях чисел Фибоначчи вычисления занимают значительное время, так как многие значения вычисляются повторно. Вам поручено создать декоратор, который кэширует результаты вызова функции и позволяет избежать повторных вычислений для одних и тех же аргументов.

# Задача
# Создайте декоратор, который кэширует (сохраняет для дальнейшего использования) результаты вызова функции и, при повторном вызове с теми же аргументами, возвращает сохранённый результат.

# Примените его к рекурсивной функции вычисления чисел Фибоначчи.
# В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и, если такие аргументы уже использовались, должен вернуть сохранённый результат вместо запуска расчёта.

# Советы
# - Для хранения результатов удобно использовать словарь, так как поиск элементов внутри словаря будет иметь сложность, равную в среднем O(1).
# - При этом не стоит хранить все вычисления в одном словаре, созданном снаружи функций (в глобальной области видимости). Лучше создавать
#  отдельные словари для каждой декорируемой функции.

# Создание декоратора.
def cache(function):
    cache = {}
    def wrapper(*args):
        if args in cache:
            return cache[args]
        result = function(*args)
        cache[args] = result
        return result
    return wrapper

# Функция рекурсивного вычисления n-го числа ряда Фибоначчи. Применение декоратора к рекурсивной функции вычисления чисел Фибоначчи.
@cache
def fibonacci(args):
    if args in (1, 2):
        return 1
    return fibonacci(args - 1) + fibonacci(args - 2)

fibonacci_cached = cache(fibonacci)
print(fibonacci_cached(10))